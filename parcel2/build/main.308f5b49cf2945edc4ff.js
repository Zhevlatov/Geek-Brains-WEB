(() => { "use strict"; Object.defineProperty({}, "__esModule", { value: !0 }); class t extends Error { } class e extends t { constructor(t) { super(`Invalid DateTime: ${t.toMessage()}`) } } class n extends t { constructor(t) { super(`Invalid Interval: ${t.toMessage()}`) } } class s extends t { constructor(t) { super(`Invalid Duration: ${t.toMessage()}`) } } class r extends t { } class i extends t { constructor(t) { super(`Invalid unit ${t}`) } } class a extends t { } class o extends t { constructor() { super("Zone is an abstract class") } } const u = "numeric", l = "short", c = "long", h = { year: u, month: u, day: u }, d = { year: u, month: l, day: u }, m = { year: u, month: c, day: u }, f = { year: u, month: c, day: u, weekday: c }, y = { hour: u, minute: u }, g = { hour: u, minute: u, second: u }, w = { hour: u, minute: u, second: u, timeZoneName: l }, p = { hour: u, minute: u, second: u, timeZoneName: c }, v = { hour: u, minute: u, hour12: !1 }, T = { hour: u, minute: u, second: u, hour12: !1 }, O = { hour: u, minute: u, second: u, hour12: !1, timeZoneName: l }, b = { hour: u, minute: u, second: u, hour12: !1, timeZoneName: c }, S = { year: u, month: u, day: u, hour: u, minute: u }, M = { year: u, month: u, day: u, hour: u, minute: u, second: u }, k = { year: u, month: l, day: u, hour: u, minute: u }, N = { year: u, month: l, day: u, hour: u, minute: u, second: u }, E = { year: u, month: l, day: u, weekday: l, hour: u, minute: u }, D = { year: u, month: c, day: u, hour: u, minute: u, timeZoneName: l }, I = { year: u, month: c, day: u, hour: u, minute: u, second: u, timeZoneName: l }, V = { year: u, month: c, day: u, weekday: c, hour: u, minute: u, timeZoneName: c }, L = { year: u, month: c, day: u, weekday: c, hour: u, minute: u, second: u, timeZoneName: c }; function x(t) { return void 0 === t } function C(t) { return "number" == typeof t } function $(t) { return "number" == typeof t && t % 1 == 0 } function F() { try { return "undefined" != typeof Intl && Intl.DateTimeFormat } catch (t) { return !1 } } function Z() { return !x(Intl.DateTimeFormat.prototype.formatToParts) } function j() { try { return "undefined" != typeof Intl && !!Intl.RelativeTimeFormat } catch (t) { return !1 } } function z(t, e, n) { if (0 !== t.length) return t.reduce(((t, s) => { const r = [e(s), s]; return t && n(t[0], r[0]) === t[0] ? t : r }), null)[1] } function A(t, e) { return e.reduce(((e, n) => (e[n] = t[n], e)), {}) } function _(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } function q(t, e, n) { return $(t) && t >= e && t <= n } function H(t, e = 2) { return t.toString().length < e ? ("0".repeat(e) + t).slice(-e) : t.toString() } function U(t) { return x(t) || null === t || "" === t ? void 0 : parseInt(t, 10) } function W(t) { if (!x(t) && null !== t && "" !== t) { const e = 1e3 * parseFloat("0." + t); return Math.floor(e) } } function R(t, e, n = !1) { const s = Math.pow(10, e); return (n ? Math.trunc : Math.round)(t * s) / s } function J(t) { return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0) } function P(t) { return J(t) ? 366 : 365 } function Y(t, e) { const n = (s = e - 1) - 12 * Math.floor(s / 12) + 1; var s; return 2 === n ? J(t + (e - n) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1] } function G(t) { let e = Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, t.second, t.millisecond); return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(e.getUTCFullYear() - 1900)), +e } function B(t) { const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7, n = t - 1, s = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7; return 4 === e || 3 === s ? 53 : 52 } function Q(t) { return t > 99 ? t : t > 60 ? 1900 + t : 2e3 + t } function K(t, e, n, s = null) { const r = new Date(t), i = { hour12: !1, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }; s && (i.timeZone = s); const a = Object.assign({ timeZoneName: e }, i), o = F(); if (o && Z()) { const t = new Intl.DateTimeFormat(n, a).formatToParts(r).find((t => "timezonename" === t.type.toLowerCase())); return t ? t.value : null } if (o) { const t = new Intl.DateTimeFormat(n, i).format(r); return new Intl.DateTimeFormat(n, a).format(r).substring(t.length).replace(/^[, \u200e]+/, "") } return null } function X(t, e) { let n = parseInt(t, 10); Number.isNaN(n) && (n = 0); const s = parseInt(e, 10) || 0; return 60 * n + (n < 0 || Object.is(n, -0) ? -s : s) } function tt(t) { const e = Number(t); if ("boolean" == typeof t || "" === t || Number.isNaN(e)) throw new a(`Invalid unit value ${t}`); return e } function et(t, e, n) { const s = {}; for (const r in t) if (_(t, r)) { if (n.indexOf(r) >= 0) continue; const i = t[r]; if (null == i) continue; s[e(r)] = tt(i) } return s } function nt(t, e) { const n = Math.trunc(t / 60), s = Math.abs(t % 60), r = n >= 0 && !Object.is(n, -0) ? "+" : "-", i = `${r}${Math.abs(n)}`; switch (e) { case "short": return `${r}${H(Math.abs(n), 2)}:${H(s, 2)}`; case "narrow": return s > 0 ? `${i}:${s}` : i; case "techie": return `${r}${H(Math.abs(n), 2)}${H(s, 2)}`; default: throw new RangeError(`Value format ${e} is out of range for property format`) } } function st(t) { return A(t, ["hour", "minute", "second", "millisecond"]) } const rt = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/; function it(t) { return JSON.stringify(t, Object.keys(t).sort()) } const at = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], ot = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ut = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]; function lt(t) { switch (t) { case "narrow": return ut; case "short": return ot; case "long": return at; case "numeric": return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]; case "2-digit": return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"]; default: return null } } const ct = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], ht = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], dt = ["M", "T", "W", "T", "F", "S", "S"]; function mt(t) { switch (t) { case "narrow": return dt; case "short": return ht; case "long": return ct; case "numeric": return ["1", "2", "3", "4", "5", "6", "7"]; default: return null } } const ft = ["AM", "PM"], yt = ["Before Christ", "Anno Domini"], gt = ["BC", "AD"], wt = ["B", "A"]; function pt(t) { switch (t) { case "narrow": return wt; case "short": return gt; case "long": return yt; default: return null } } function vt(t, e) { let n = ""; for (const s of t) s.literal ? n += s.val : n += e(s.val); return n } const Tt = { D: h, DD: d, DDD: m, DDDD: f, t: y, tt: g, ttt: w, tttt: p, T: v, TT: T, TTT: O, TTTT: b, f: S, ff: k, fff: D, ffff: V, F: M, FF: N, FFF: I, FFFF: L }; class Ot { static create(t, e = {}) { return new Ot(t, e) } static parseFormat(t) { let e = null, n = "", s = !1; const r = []; for (let i = 0; i < t.length; i++) { const a = t.charAt(i); "'" === a ? (n.length > 0 && r.push({ literal: s, val: n }), e = null, n = "", s = !s) : s || a === e ? n += a : (n.length > 0 && r.push({ literal: !1, val: n }), n = a, e = a) } return n.length > 0 && r.push({ literal: s, val: n }), r } static macroTokenToFormatOpts(t) { return Tt[t] } constructor(t, e) { this.opts = e, this.loc = t, this.systemLoc = null } formatWithSystemDefault(t, e) { return null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, Object.assign({}, this.opts, e)).format() } formatDateTime(t, e = {}) { return this.loc.dtFormatter(t, Object.assign({}, this.opts, e)).format() } formatDateTimeParts(t, e = {}) { return this.loc.dtFormatter(t, Object.assign({}, this.opts, e)).formatToParts() } resolvedOptions(t, e = {}) { return this.loc.dtFormatter(t, Object.assign({}, this.opts, e)).resolvedOptions() } num(t, e = 0) { if (this.opts.forceSimple) return H(t, e); const n = Object.assign({}, this.opts); return e > 0 && (n.padTo = e), this.loc.numberFormatter(n).format(t) } formatDateTimeFromString(t, e) { const n = "en" === this.loc.listingMode(), s = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar && Z(), r = (e, n) => this.loc.extract(t, e, n), i = e => t.isOffsetFixed && 0 === t.offset && e.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, e.format) : "", a = (e, s) => n ? function (t, e) { return lt(e)[t.month - 1] }(t, e) : r(s ? { month: e } : { month: e, day: "numeric" }, "month"), o = (e, s) => n ? function (t, e) { return mt(e)[t.weekday - 1] }(t, e) : r(s ? { weekday: e } : { weekday: e, month: "long", day: "numeric" }, "weekday"), u = e => { const n = Ot.macroTokenToFormatOpts(e); return n ? this.formatWithSystemDefault(t, n) : e }, l = e => n ? function (t, e) { return pt(e)[t.year < 0 ? 0 : 1] }(t, e) : r({ era: e }, "era"); return vt(Ot.parseFormat(e), (e => { switch (e) { case "S": return this.num(t.millisecond); case "u": case "SSS": return this.num(t.millisecond, 3); case "s": return this.num(t.second); case "ss": return this.num(t.second, 2); case "m": return this.num(t.minute); case "mm": return this.num(t.minute, 2); case "h": return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12); case "hh": return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12, 2); case "H": return this.num(t.hour); case "HH": return this.num(t.hour, 2); case "Z": return i({ format: "narrow", allowZ: this.opts.allowZ }); case "ZZ": return i({ format: "short", allowZ: this.opts.allowZ }); case "ZZZ": return i({ format: "techie", allowZ: this.opts.allowZ }); case "ZZZZ": return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale }); case "ZZZZZ": return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale }); case "z": return t.zoneName; case "a": return n ? function (t) { return ft[t.hour < 12 ? 0 : 1] }(t) : r({ hour: "numeric", hour12: !0 }, "dayperiod"); case "d": return s ? r({ day: "numeric" }, "day") : this.num(t.day); case "dd": return s ? r({ day: "2-digit" }, "day") : this.num(t.day, 2); case "c": case "E": return this.num(t.weekday); case "ccc": return o("short", !0); case "cccc": return o("long", !0); case "ccccc": return o("narrow", !0); case "EEE": return o("short", !1); case "EEEE": return o("long", !1); case "EEEEE": return o("narrow", !1); case "L": return s ? r({ month: "numeric", day: "numeric" }, "month") : this.num(t.month); case "LL": return s ? r({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2); case "LLL": return a("short", !0); case "LLLL": return a("long", !0); case "LLLLL": return a("narrow", !0); case "M": return s ? r({ month: "numeric" }, "month") : this.num(t.month); case "MM": return s ? r({ month: "2-digit" }, "month") : this.num(t.month, 2); case "MMM": return a("short", !1); case "MMMM": return a("long", !1); case "MMMMM": return a("narrow", !1); case "y": return s ? r({ year: "numeric" }, "year") : this.num(t.year); case "yy": return s ? r({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2); case "yyyy": return s ? r({ year: "numeric" }, "year") : this.num(t.year, 4); case "yyyyyy": return s ? r({ year: "numeric" }, "year") : this.num(t.year, 6); case "G": return l("short"); case "GG": return l("long"); case "GGGGG": return l("narrow"); case "kk": return this.num(t.weekYear.toString().slice(-2), 2); case "kkkk": return this.num(t.weekYear, 4); case "W": return this.num(t.weekNumber); case "WW": return this.num(t.weekNumber, 2); case "o": return this.num(t.ordinal); case "ooo": return this.num(t.ordinal, 3); case "q": return this.num(t.quarter); case "qq": return this.num(t.quarter, 2); case "X": return this.num(Math.floor(t.ts / 1e3)); case "x": return this.num(t.ts); default: return u(e) } })) } formatDurationFromString(t, e) { const n = t => { switch (t[0]) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": return "hour"; case "d": return "day"; case "M": return "month"; case "y": return "year"; default: return null } }, s = Ot.parseFormat(e), r = s.reduce(((t, { literal: e, val: n }) => e ? t : t.concat(n)), []); return vt(s, (t => e => { const s = n(e); return s ? this.num(t.get(s), e.length) : e })(t.shiftTo(...r.map(n).filter((t => t))))) } } class bt { constructor(t, e) { this.reason = t, this.explanation = e } toMessage() { return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason } } class St { get type() { throw new o } get name() { throw new o } get universal() { throw new o } offsetName(t, e) { throw new o } formatOffset(t, e) { throw new o } offset(t) { throw new o } equals(t) { throw new o } get isValid() { throw new o } } let Mt = null; class kt extends St { static get instance() { return null === Mt && (Mt = new kt), Mt } get type() { return "local" } get name() { return F() ? (new Intl.DateTimeFormat).resolvedOptions().timeZone : "local" } get universal() { return !1 } offsetName(t, { format: e, locale: n }) { return K(t, e, n) } formatOffset(t, e) { return nt(this.offset(t), e) } offset(t) { return -new Date(t).getTimezoneOffset() } equals(t) { return "local" === t.type } get isValid() { return !0 } } const Nt = RegExp(`^${rt.source}$`); let Et = {}; const Dt = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }; let It = {}; class Vt extends St { static create(t) { return It[t] || (It[t] = new Vt(t)), It[t] } static resetCache() { It = {}, Et = {} } static isValidSpecifier(t) { return !(!t || !t.match(Nt)) } static isValidZone(t) { try { return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0 } catch (t) { return !1 } } static parseGMTOffset(t) { if (t) { const e = t.match(/^Etc\/GMT([+-]\d{1,2})$/i); if (e) return -60 * parseInt(e[1]) } return null } constructor(t) { super(), this.zoneName = t, this.valid = Vt.isValidZone(t) } get type() { return "iana" } get name() { return this.zoneName } get universal() { return !1 } offsetName(t, { format: e, locale: n }) { return K(t, e, n, this.name) } formatOffset(t, e) { return nt(this.offset(t), e) } offset(t) { const e = new Date(t), n = (l = this.name, Et[l] || (Et[l] = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: l, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" })), Et[l]), [s, r, i, a, o, u] = n.formatToParts ? function (t, e) { const n = t.formatToParts(e), s = []; for (let t = 0; t < n.length; t++) { const { type: e, value: r } = n[t], i = Dt[e]; x(i) || (s[i] = parseInt(r, 10)) } return s }(n, e) : function (t, e) { const n = t.format(e).replace(/\u200E/g, ""), s = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(n), [, r, i, a, o, u, l] = s; return [a, r, i, o, u, l] }(n, e); var l; let c = +e; const h = c % 1e3; return c -= h >= 0 ? h : 1e3 + h, (G({ year: s, month: r, day: i, hour: 24 === a ? 0 : a, minute: o, second: u, millisecond: 0 }) - c) / 6e4 } equals(t) { return "iana" === t.type && t.name === this.name } get isValid() { return this.valid } } let Lt = null; class xt extends St { static get utcInstance() { return null === Lt && (Lt = new xt(0)), Lt } static instance(t) { return 0 === t ? xt.utcInstance : new xt(t) } static parseSpecifier(t) { if (t) { const e = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i); if (e) return new xt(X(e[1], e[2])) } return null } constructor(t) { super(), this.fixed = t } get type() { return "fixed" } get name() { return 0 === this.fixed ? "UTC" : `UTC${nt(this.fixed, "narrow")}` } offsetName() { return this.name } formatOffset(t, e) { return nt(this.fixed, e) } get universal() { return !0 } offset() { return this.fixed } equals(t) { return "fixed" === t.type && t.fixed === this.fixed } get isValid() { return !0 } } class Ct extends St { constructor(t) { super(), this.zoneName = t } get type() { return "invalid" } get name() { return this.zoneName } get universal() { return !1 } offsetName() { return null } formatOffset() { return "" } offset() { return NaN } equals() { return !1 } get isValid() { return !1 } } function $t(t, e) { let n; if (x(t) || null === t) return e; if (t instanceof St) return t; if ("string" == typeof t) { const s = t.toLowerCase(); return "local" === s ? e : "utc" === s || "gmt" === s ? xt.utcInstance : null != (n = Vt.parseGMTOffset(t)) ? xt.instance(n) : Vt.isValidSpecifier(s) ? Vt.create(t) : xt.parseSpecifier(s) || new Ct(t) } return C(t) ? xt.instance(t) : "object" == typeof t && t.offset && "number" == typeof t.offset ? t : new Ct(t) } let Ft = () => Date.now(), Zt = null, jt = null, zt = null, At = null, _t = !1; class qt { static get now() { return Ft } static set now(t) { Ft = t } static get defaultZoneName() { return qt.defaultZone.name } static set defaultZoneName(t) { Zt = t ? $t(t) : null } static get defaultZone() { return Zt || kt.instance } static get defaultLocale() { return jt } static set defaultLocale(t) { jt = t } static get defaultNumberingSystem() { return zt } static set defaultNumberingSystem(t) { zt = t } static get defaultOutputCalendar() { return At } static set defaultOutputCalendar(t) { At = t } static get throwOnInvalid() { return _t } static set throwOnInvalid(t) { _t = t } static resetCaches() { Qt.resetCache(), Vt.resetCache() } } let Ht = {}; function Ut(t, e = {}) { const n = JSON.stringify([t, e]); let s = Ht[n]; return s || (s = new Intl.DateTimeFormat(t, e), Ht[n] = s), s } let Wt = {}, Rt = {}; let Jt = null; function Pt(t, e, n, s, r) { const i = t.listingMode(n); return "error" === i ? null : "en" === i ? s(e) : r(e) } class Yt { constructor(t, e, n) { if (this.padTo = n.padTo || 0, this.floor = n.floor || !1, !e && F()) { const e = { useGrouping: !1 }; n.padTo > 0 && (e.minimumIntegerDigits = n.padTo), this.inf = function (t, e = {}) { const n = JSON.stringify([t, e]); let s = Wt[n]; return s || (s = new Intl.NumberFormat(t, e), Wt[n] = s), s }(t, e) } } format(t) { if (this.inf) { const e = this.floor ? Math.floor(t) : t; return this.inf.format(e) } return H(this.floor ? Math.floor(t) : R(t, 3), this.padTo) } } class Gt { constructor(t, e, n) { let s; if (this.opts = n, this.hasIntl = F(), t.zone.universal && this.hasIntl ? (s = "UTC", n.timeZoneName ? this.dt = t : this.dt = 0 === t.offset ? t : Rn.fromMillis(t.ts + 60 * t.offset * 1e3)) : "local" === t.zone.type ? this.dt = t : (this.dt = t, s = t.zone.name), this.hasIntl) { const t = Object.assign({}, this.opts); s && (t.timeZone = s), this.dtf = Ut(e, t) } } format() { if (this.hasIntl) return this.dtf.format(this.dt.toJSDate()); { const t = function (t) { const e = "EEEE, LLLL d, yyyy, h:mm a"; switch (it(A(t, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]))) { case it(h): return "M/d/yyyy"; case it(d): return "LLL d, yyyy"; case it(m): return "LLLL d, yyyy"; case it(f): return "EEEE, LLLL d, yyyy"; case it(y): return "h:mm a"; case it(g): return "h:mm:ss a"; case it(w): case it(p): return "h:mm a"; case it(v): return "HH:mm"; case it(T): return "HH:mm:ss"; case it(O): case it(b): return "HH:mm"; case it(S): return "M/d/yyyy, h:mm a"; case it(k): return "LLL d, yyyy, h:mm a"; case it(D): return "LLLL d, yyyy, h:mm a"; case it(V): return e; case it(M): return "M/d/yyyy, h:mm:ss a"; case it(N): return "LLL d, yyyy, h:mm:ss a"; case it(E): return "EEE, d LLL yyyy, h:mm a"; case it(I): return "LLLL d, yyyy, h:mm:ss a"; case it(L): return "EEEE, LLLL d, yyyy, h:mm:ss a"; default: return e } }(this.opts), e = Qt.create("en-US"); return Ot.create(e).formatDateTimeFromString(this.dt, t) } } formatToParts() { return this.hasIntl && Z() ? this.dtf.formatToParts(this.dt.toJSDate()) : [] } resolvedOptions() { return this.hasIntl ? this.dtf.resolvedOptions() : { locale: "en-US", numberingSystem: "latn", outputCalendar: "gregory" } } } class Bt { constructor(t, e, n) { this.opts = Object.assign({ style: "long" }, n), !e && j() && (this.rtf = function (t, e = {}) { const n = function (t, e) { if (null == t) return {}; var n, s, r = {}, i = Object.keys(t); for (s = 0; s < i.length; s++)n = i[s], e.indexOf(n) >= 0 || (r[n] = t[n]); return r }(e, ["base"]), s = JSON.stringify([t, n]); let r = Rt[s]; return r || (r = new Intl.RelativeTimeFormat(t, e), Rt[s] = r), r }(t, n)) } format(t, e) { return this.rtf ? this.rtf.format(t, e) : function (t, e, n = "always", s = !1) { const r = { years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."] }, i = -1 === ["hours", "minutes", "seconds"].indexOf(t); if ("auto" === n && i) { const n = "days" === t; switch (e) { case 1: return n ? "tomorrow" : `next ${r[t][0]}`; case -1: return n ? "yesterday" : `last ${r[t][0]}`; case 0: return n ? "today" : `this ${r[t][0]}` } } const a = Object.is(e, -0) || e < 0, o = Math.abs(e), u = 1 === o, l = r[t], c = s ? u ? l[1] : l[2] || l[1] : u ? r[t][0] : t; return a ? `${o} ${c} ago` : `in ${o} ${c}` }(e, t, this.opts.numeric, "long" !== this.opts.style) } formatToParts(t, e) { return this.rtf ? this.rtf.formatToParts(t, e) : [] } } class Qt { static fromOpts(t) { return Qt.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN) } static create(t, e, n, s = !1) { const r = t || qt.defaultLocale, i = r || (s ? "en-US" : function () { if (Jt) return Jt; if (F()) { const t = (new Intl.DateTimeFormat).resolvedOptions().locale; return Jt = t && "und" !== t ? t : "en-US", Jt } return Jt = "en-US", Jt }()), a = e || qt.defaultNumberingSystem, o = n || qt.defaultOutputCalendar; return new Qt(i, a, o, r) } static resetCache() { Jt = null, Ht = {}, Wt = {}, Rt = {} } static fromObject({ locale: t, numberingSystem: e, outputCalendar: n } = {}) { return Qt.create(t, e, n) } constructor(t, e, n, s) { const [r, i, a] = function (t) { const e = t.indexOf("-u-"); if (-1 === e) return [t]; { let n; const s = t.substring(0, e); try { n = Ut(t).resolvedOptions() } catch (t) { n = Ut(s).resolvedOptions() } const { numberingSystem: r, calendar: i } = n; return [s, r, i] } }(t); this.locale = r, this.numberingSystem = e || i || null, this.outputCalendar = n || a || null, this.intl = function (t, e, n) { return F() ? n || e ? (t += "-u", n && (t += `-ca-${n}`), e && (t += `-nu-${e}`), t) : t : [] }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null } get fastNumbers() { var t; return null == this.fastNumbersCached && (this.fastNumbersCached = (!(t = this).numberingSystem || "latn" === t.numberingSystem) && ("latn" === t.numberingSystem || !t.locale || t.locale.startsWith("en") || F() && "latn" === new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)), this.fastNumbersCached } listingMode(t = !0) { const e = F() && Z(), n = this.isEnglish(), s = !(null !== this.numberingSystem && "latn" !== this.numberingSystem || null !== this.outputCalendar && "gregory" !== this.outputCalendar); return e || n && s || t ? !e || n && s ? "en" : "intl" : "error" } clone(t) { return t && 0 !== Object.getOwnPropertyNames(t).length ? Qt.create(t.locale || this.specifiedLocale, t.numberingSystem || this.numberingSystem, t.outputCalendar || this.outputCalendar, t.defaultToEN || !1) : this } redefaultToEN(t = {}) { return this.clone(Object.assign({}, t, { defaultToEN: !0 })) } redefaultToSystem(t = {}) { return this.clone(Object.assign({}, t, { defaultToEN: !1 })) } months(t, e = !1, n = !0) { return Pt(this, t, n, lt, (() => { const n = e ? { month: t, day: "numeric" } : { month: t }, s = e ? "format" : "standalone"; return this.monthsCache[s][t] || (this.monthsCache[s][t] = function (t) { const e = []; for (let n = 1; n <= 12; n++) { const s = Rn.utc(2016, n, 1); e.push(t(s)) } return e }((t => this.extract(t, n, "month")))), this.monthsCache[s][t] })) } weekdays(t, e = !1, n = !0) { return Pt(this, t, n, mt, (() => { const n = e ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, s = e ? "format" : "standalone"; return this.weekdaysCache[s][t] || (this.weekdaysCache[s][t] = function (t) { const e = []; for (let n = 1; n <= 7; n++) { const s = Rn.utc(2016, 11, 13 + n); e.push(t(s)) } return e }((t => this.extract(t, n, "weekday")))), this.weekdaysCache[s][t] })) } meridiems(t = !0) { return Pt(this, void 0, t, (() => ft), (() => { if (!this.meridiemCache) { const t = { hour: "numeric", hour12: !0 }; this.meridiemCache = [Rn.utc(2016, 11, 13, 9), Rn.utc(2016, 11, 13, 19)].map((e => this.extract(e, t, "dayperiod"))) } return this.meridiemCache })) } eras(t, e = !0) { return Pt(this, t, e, pt, (() => { const e = { era: t }; return this.eraCache[t] || (this.eraCache[t] = [Rn.utc(-40, 1, 1), Rn.utc(2017, 1, 1)].map((t => this.extract(t, e, "era")))), this.eraCache[t] })) } extract(t, e, n) { const s = this.dtFormatter(t, e).formatToParts().find((t => t.type.toLowerCase() === n)); return s ? s.value : null } numberFormatter(t = {}) { return new Yt(this.intl, t.forceSimple || this.fastNumbers, t) } dtFormatter(t, e = {}) { return new Gt(t, this.intl, e) } relFormatter(t = {}) { return new Bt(this.intl, this.isEnglish(), t) } isEnglish() { return "en" === this.locale || "en-us" === this.locale.toLowerCase() || F() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us") } equals(t) { return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar } } function Kt(...t) { const e = t.reduce(((t, e) => t + e.source), ""); return RegExp(`^${e}$`) } function Xt(...t) { return e => t.reduce((([t, n, s], r) => { const [i, a, o] = r(e, s); return [Object.assign(t, i), n || a, o] }), [{}, null, 1]).slice(0, 2) } function te(t, ...e) { if (null == t) return [null, null]; for (const [n, s] of e) { const e = n.exec(t); if (e) return s(e) } return [null, null] } function ee(...t) { return (e, n) => { const s = {}; let r; for (r = 0; r < t.length; r++)s[t[r]] = U(e[n + r]); return [s, null, n + r] } } const ne = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, se = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,9}))?)?)?/, re = RegExp(`${se.source}${ne.source}?`), ie = RegExp(`(?:T${re.source})?`), ae = ee("weekYear", "weekNumber", "weekDay"), oe = ee("year", "ordinal"), ue = RegExp(`${se.source} ?(?:${ne.source}|(${rt.source}))?`), le = RegExp(`(?: ${ue.source})?`); function ce(t, e, n) { const s = t[e]; return x(s) ? n : U(s) } function he(t, e) { return [{ year: ce(t, e), month: ce(t, e + 1, 1), day: ce(t, e + 2, 1) }, null, e + 3] } function de(t, e) { return [{ hour: ce(t, e, 0), minute: ce(t, e + 1, 0), second: ce(t, e + 2, 0), millisecond: W(t[e + 3]) }, null, e + 4] } function me(t, e) { const n = !t[e] && !t[e + 1], s = X(t[e + 1], t[e + 2]); return [{}, n ? null : xt.instance(s), e + 3] } function fe(t, e) { return [{}, t[e] ? Vt.create(t[e]) : null, e + 1] } const ye = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})(?:[.,](-?\d{1,9}))?S)?)?)$/; function ge(t) { const [e, n, s, r, i, a, o, u, l] = t, c = "-" === e[0], h = t => t && c ? -t : t; return [{ years: h(U(n)), months: h(U(s)), weeks: h(U(r)), days: h(U(i)), hours: h(U(a)), minutes: h(U(o)), seconds: h(U(u)), milliseconds: h(W(l)) }] } const we = { GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 }; function pe(t, e, n, s, r, i, a) { const o = { year: 2 === e.length ? Q(U(e)) : U(e), month: ot.indexOf(n) + 1, day: U(s), hour: U(r), minute: U(i) }; return a && (o.second = U(a)), t && (o.weekday = t.length > 3 ? ct.indexOf(t) + 1 : ht.indexOf(t) + 1), o } const ve = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/; function Te(t) { const [, e, n, s, r, i, a, o, u, l, c, h] = t, d = pe(e, r, s, n, i, a, o); let m; return m = u ? we[u] : l ? 0 : X(c, h), [d, new xt(m)] } const Oe = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, be = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Se = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/; function Me(t) { const [, e, n, s, r, i, a, o] = t; return [pe(e, r, s, n, i, a, o), xt.utcInstance] } function ke(t) { const [, e, n, s, r, i, a, o] = t; return [pe(e, o, n, s, r, i, a), xt.utcInstance] } const Ne = Kt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, ie), Ee = Kt(/(\d{4})-?W(\d\d)(?:-?(\d))?/, ie), De = Kt(/(\d{4})-?(\d{3})/, ie), Ie = Kt(re), Ve = Xt(he, de, me), Le = Xt(ae, de, me), xe = Xt(oe, de), Ce = Xt(de, me), $e = Kt(/(\d{4})-(\d\d)-(\d\d)/, le), Fe = Kt(ue), Ze = Xt(he, de, me, fe), je = Xt(de, me, fe), ze = { weeks: { days: 7, hours: 168, minutes: 10080, seconds: 604800, milliseconds: 6048e5 }, days: { hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864e5 }, hours: { minutes: 60, seconds: 3600, milliseconds: 36e5 }, minutes: { seconds: 60, milliseconds: 6e4 }, seconds: { milliseconds: 1e3 } }, Ae = Object.assign({ years: { months: 12, weeks: 52, days: 365, hours: 8760, minutes: 525600, seconds: 31536e3, milliseconds: 31536e6 }, quarters: { months: 3, weeks: 13, days: 91, hours: 2184, minutes: 131040, milliseconds: 78624e5 }, months: { weeks: 4, days: 30, hours: 720, minutes: 43200, seconds: 2592e3, milliseconds: 2592e6 } }, ze), _e = Object.assign({ years: { months: 12, weeks: 52.1775, days: 365.2425, hours: 8765.82, minutes: 525949.2, seconds: 525949.2 * 60, milliseconds: 525949.2 * 60 * 1e3 }, quarters: { months: 3, weeks: 13.044375, days: 91.310625, hours: 2191.455, minutes: 131487.3, seconds: 525949.2 * 60 / 4, milliseconds: 7889237999.999999 }, months: { weeks: 4.3481250000000005, days: 30.436875, hours: 730.485, minutes: 43829.1, seconds: 2629746, milliseconds: 2629746e3 } }, ze), qe = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], He = qe.slice(0).reverse(); function Ue(t, e, n = !1) { const s = { values: n ? e.values : Object.assign({}, t.values, e.values || {}), loc: t.loc.clone(e.loc), conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy }; return new Je(s) } function We(t, e, n, s, r) { const i = t[r][n], a = e[n] / i, o = Math.sign(a) !== Math.sign(s[r]) && 0 !== s[r] && Math.abs(a) <= 1 ? function (t) { return t < 0 ? Math.floor(t) : Math.ceil(t) }(a) : Math.trunc(a); s[r] += o, e[n] -= o * i } function Re(t, e) { He.reduce(((n, s) => x(e[s]) ? n : (n && We(t, e, n, e, s), s)), null) } class Je { constructor(t) { const e = "longterm" === t.conversionAccuracy || !1; this.values = t.values, this.loc = t.loc || Qt.create(), this.conversionAccuracy = e ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = e ? _e : Ae, this.isLuxonDuration = !0 } static fromMillis(t, e) { return Je.fromObject(Object.assign({ milliseconds: t }, e)) } static fromObject(t) { if (null == t || "object" != typeof t) throw new a("Duration.fromObject: argument expected to be an object, got " + (null === t ? "null" : typeof t)); return new Je({ values: et(t, Je.normalizeUnit, ["locale", "numberingSystem", "conversionAccuracy", "zone"]), loc: Qt.fromObject(t), conversionAccuracy: t.conversionAccuracy }) } static fromISO(t, e) { const [n] = function (t) { return te(t, [ye, ge]) }(t); if (n) { const t = Object.assign(n, e); return Je.fromObject(t) } return Je.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`) } static invalid(t, e = null) { if (!t) throw new a("need to specify a reason the Duration is invalid"); const n = t instanceof bt ? t : new bt(t, e); if (qt.throwOnInvalid) throw new s(n); return new Je({ invalid: n }) } static normalizeUnit(t) { const e = { year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds" }[t ? t.toLowerCase() : t]; if (!e) throw new i(t); return e } static isDuration(t) { return t && t.isLuxonDuration || !1 } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } toFormat(t, e = {}) { const n = Object.assign({}, e, { floor: !1 !== e.round && !1 !== e.floor }); return this.isValid ? Ot.create(this.loc, n).formatDurationFromString(this, t) : "Invalid Duration" } toObject(t = {}) { if (!this.isValid) return {}; const e = Object.assign({}, this.values); return t.includeConfig && (e.conversionAccuracy = this.conversionAccuracy, e.numberingSystem = this.loc.numberingSystem, e.locale = this.loc.locale), e } toISO() { if (!this.isValid) return null; let t = "P"; return 0 !== this.years && (t += this.years + "Y"), 0 === this.months && 0 === this.quarters || (t += this.months + 3 * this.quarters + "M"), 0 !== this.weeks && (t += this.weeks + "W"), 0 !== this.days && (t += this.days + "D"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (t += "T"), 0 !== this.hours && (t += this.hours + "H"), 0 !== this.minutes && (t += this.minutes + "M"), 0 === this.seconds && 0 === this.milliseconds || (t += R(this.seconds + this.milliseconds / 1e3, 3) + "S"), "P" === t && (t += "T0S"), t } toJSON() { return this.toISO() } toString() { return this.toISO() } valueOf() { return this.as("milliseconds") } plus(t) { if (!this.isValid) return this; const e = Pe(t), n = {}; for (const t of qe) (_(e.values, t) || _(this.values, t)) && (n[t] = e.get(t) + this.get(t)); return Ue(this, { values: n }, !0) } minus(t) { if (!this.isValid) return this; const e = Pe(t); return this.plus(e.negate()) } mapUnits(t) { if (!this.isValid) return this; const e = {}; for (const n of Object.keys(this.values)) e[n] = tt(t(this.values[n], n)); return Ue(this, { values: e }, !0) } get(t) { return this[Je.normalizeUnit(t)] } set(t) { return this.isValid ? Ue(this, { values: Object.assign(this.values, et(t, Je.normalizeUnit, [])) }) : this } reconfigure({ locale: t, numberingSystem: e, conversionAccuracy: n } = {}) { const s = { loc: this.loc.clone({ locale: t, numberingSystem: e }) }; return n && (s.conversionAccuracy = n), Ue(this, s) } as(t) { return this.isValid ? this.shiftTo(t).get(t) : NaN } normalize() { if (!this.isValid) return this; const t = this.toObject(); return Re(this.matrix, t), Ue(this, { values: t }, !0) } shiftTo(...t) { if (!this.isValid) return this; if (0 === t.length) return this; t = t.map((t => Je.normalizeUnit(t))); const e = {}, n = {}, s = this.toObject(); let r; Re(this.matrix, s); for (const i of qe) if (t.indexOf(i) >= 0) { r = i; let t = 0; for (const e in n) t += this.matrix[e][i] * n[e], n[e] = 0; C(s[i]) && (t += s[i]); const a = Math.trunc(t); e[i] = a, n[i] = t - a; for (const t in s) qe.indexOf(t) > qe.indexOf(i) && We(this.matrix, s, t, e, i) } else C(s[i]) && (n[i] = s[i]); for (const t in n) 0 !== n[t] && (e[r] += t === r ? n[t] : n[t] / this.matrix[r][t]); return Ue(this, { values: e }, !0).normalize() } negate() { if (!this.isValid) return this; const t = {}; for (const e of Object.keys(this.values)) t[e] = -this.values[e]; return Ue(this, { values: t }, !0) } get years() { return this.isValid ? this.values.years || 0 : NaN } get quarters() { return this.isValid ? this.values.quarters || 0 : NaN } get months() { return this.isValid ? this.values.months || 0 : NaN } get weeks() { return this.isValid ? this.values.weeks || 0 : NaN } get days() { return this.isValid ? this.values.days || 0 : NaN } get hours() { return this.isValid ? this.values.hours || 0 : NaN } get minutes() { return this.isValid ? this.values.minutes || 0 : NaN } get seconds() { return this.isValid ? this.values.seconds || 0 : NaN } get milliseconds() { return this.isValid ? this.values.milliseconds || 0 : NaN } get isValid() { return null === this.invalid } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } equals(t) { if (!this.isValid || !t.isValid) return !1; if (!this.loc.equals(t.loc)) return !1; for (const e of qe) if (this.values[e] !== t.values[e]) return !1; return !0 } } function Pe(t) { if (C(t)) return Je.fromMillis(t); if (Je.isDuration(t)) return t; if ("object" == typeof t) return Je.fromObject(t); throw new a(`Unknown duration argument ${t} of type ${typeof t}`) } const Ye = "Invalid Interval"; class Ge { constructor(t) { this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0 } static invalid(t, e = null) { if (!t) throw new a("need to specify a reason the Interval is invalid"); const s = t instanceof bt ? t : new bt(t, e); if (qt.throwOnInvalid) throw new n(s); return new Ge({ invalid: s }) } static fromDateTimes(t, e) { const n = Jn(t), s = Jn(e), r = function (t, e) { return t && t.isValid ? e && e.isValid ? e < t ? Ge.invalid("end before start", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null : Ge.invalid("missing or invalid end") : Ge.invalid("missing or invalid start") }(n, s); return null == r ? new Ge({ start: n, end: s }) : r } static after(t, e) { const n = Pe(e), s = Jn(t); return Ge.fromDateTimes(s, s.plus(n)) } static before(t, e) { const n = Pe(e), s = Jn(t); return Ge.fromDateTimes(s.minus(n), s) } static fromISO(t, e) { const [n, s] = (t || "").split("/", 2); if (n && s) { const t = Rn.fromISO(n, e), r = Rn.fromISO(s, e); if (t.isValid && r.isValid) return Ge.fromDateTimes(t, r); if (t.isValid) { const n = Je.fromISO(s, e); if (n.isValid) return Ge.after(t, n) } else if (r.isValid) { const t = Je.fromISO(n, e); if (t.isValid) return Ge.before(r, t) } } return Ge.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`) } static isInterval(t) { return t && t.isLuxonInterval || !1 } get start() { return this.isValid ? this.s : null } get end() { return this.isValid ? this.e : null } get isValid() { return null === this.invalidReason } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } length(t = "milliseconds") { return this.isValid ? this.toDuration(t).get(t) : NaN } count(t = "milliseconds") { if (!this.isValid) return NaN; const e = this.start.startOf(t), n = this.end.startOf(t); return Math.floor(n.diff(e, t).get(t)) + 1 } hasSame(t) { return !!this.isValid && this.e.minus(1).hasSame(this.s, t) } isEmpty() { return this.s.valueOf() === this.e.valueOf() } isAfter(t) { return !!this.isValid && this.s > t } isBefore(t) { return !!this.isValid && this.e <= t } contains(t) { return !!this.isValid && this.s <= t && this.e > t } set({ start: t, end: e } = {}) { return this.isValid ? Ge.fromDateTimes(t || this.s, e || this.e) : this } splitAt(...t) { if (!this.isValid) return []; const e = t.map(Jn).filter((t => this.contains(t))).sort(), n = []; let { s } = this, r = 0; for (; s < this.e;) { const t = e[r] || this.e, i = +t > +this.e ? this.e : t; n.push(Ge.fromDateTimes(s, i)), s = i, r += 1 } return n } splitBy(t) { const e = Pe(t); if (!this.isValid || !e.isValid || 0 === e.as("milliseconds")) return []; let n, s, { s: r } = this; const i = []; for (; r < this.e;)n = r.plus(e), s = +n > +this.e ? this.e : n, i.push(Ge.fromDateTimes(r, s)), r = s; return i } divideEqually(t) { return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [] } overlaps(t) { return this.e > t.s && this.s < t.e } abutsStart(t) { return !!this.isValid && +this.e == +t.s } abutsEnd(t) { return !!this.isValid && +t.e == +this.s } engulfs(t) { return !!this.isValid && this.s <= t.s && this.e >= t.e } equals(t) { return !(!this.isValid || !t.isValid) && this.s.equals(t.s) && this.e.equals(t.e) } intersection(t) { if (!this.isValid) return this; const e = this.s > t.s ? this.s : t.s, n = this.e < t.e ? this.e : t.e; return e > n ? null : Ge.fromDateTimes(e, n) } union(t) { if (!this.isValid) return this; const e = this.s < t.s ? this.s : t.s, n = this.e > t.e ? this.e : t.e; return Ge.fromDateTimes(e, n) } static merge(t) { const [e, n] = t.sort(((t, e) => t.s - e.s)).reduce((([t, e], n) => e ? e.overlaps(n) || e.abutsStart(n) ? [t, e.union(n)] : [t.concat([e]), n] : [t, n]), [[], null]); return n && e.push(n), e } static xor(t) { let e = null, n = 0; const s = [], r = t.map((t => [{ time: t.s, type: "s" }, { time: t.e, type: "e" }])), i = Array.prototype.concat(...r).sort(((t, e) => t.time - e.time)); for (const t of i) n += "s" === t.type ? 1 : -1, 1 === n ? e = t.time : (e && +e != +t.time && s.push(Ge.fromDateTimes(e, t.time)), e = null); return Ge.merge(s) } difference(...t) { return Ge.xor([this].concat(t)).map((t => this.intersection(t))).filter((t => t && !t.isEmpty())) } toString() { return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : Ye } toISO(t) { return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : Ye } toISODate() { return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Ye } toISOTime(t) { return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : Ye } toFormat(t, { separator: e = " – " } = {}) { return this.isValid ? `${this.s.toFormat(t)}${e}${this.e.toFormat(t)}` : Ye } toDuration(t, e) { return this.isValid ? this.e.diff(this.s, t, e) : Je.invalid(this.invalidReason) } mapEndpoints(t) { return Ge.fromDateTimes(t(this.s), t(this.e)) } } class Be { static hasDST(t = qt.defaultZone) { const e = Rn.local().setZone(t).set({ month: 12 }); return !t.universal && e.offset !== e.set({ month: 6 }).offset } static isValidIANAZone(t) { return Vt.isValidSpecifier(t) && Vt.isValidZone(t) } static normalizeZone(t) { return $t(t, qt.defaultZone) } static months(t = "long", { locale: e = null, numberingSystem: n = null, outputCalendar: s = "gregory" } = {}) { return Qt.create(e, n, s).months(t) } static monthsFormat(t = "long", { locale: e = null, numberingSystem: n = null, outputCalendar: s = "gregory" } = {}) { return Qt.create(e, n, s).months(t, !0) } static weekdays(t = "long", { locale: e = null, numberingSystem: n = null } = {}) { return Qt.create(e, n, null).weekdays(t) } static weekdaysFormat(t = "long", { locale: e = null, numberingSystem: n = null } = {}) { return Qt.create(e, n, null).weekdays(t, !0) } static meridiems({ locale: t = null } = {}) { return Qt.create(t).meridiems() } static eras(t = "short", { locale: e = null } = {}) { return Qt.create(e, null, "gregory").eras(t) } static features() { let t = !1, e = !1, n = !1, s = !1; if (F()) { t = !0, e = Z(), s = j(); try { n = "America/New_York" === new Intl.DateTimeFormat("en", { timeZone: "America/New_York" }).resolvedOptions().timeZone } catch (t) { n = !1 } } return { intl: t, intlTokens: e, zones: n, relative: s } } } function Qe(t, e) { const n = t => t.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), s = n(e) - n(t); return Math.floor(Je.fromMillis(s).as("days")) } const Ke = { arab: "[٠-٩]", arabext: "[۰-۹]", bali: "[᭐-᭙]", beng: "[০-৯]", deva: "[०-९]", fullwide: "[０-９]", gujr: "[૦-૯]", hanidec: "[〇|一|二|三|四|五|六|七|八|九]", khmr: "[០-៩]", knda: "[೦-೯]", laoo: "[໐-໙]", limb: "[᥆-᥏]", mlym: "[൦-൯]", mong: "[᠐-᠙]", mymr: "[၀-၉]", orya: "[୦-୯]", tamldec: "[௦-௯]", telu: "[౦-౯]", thai: "[๐-๙]", tibt: "[༠-༩]", latn: "\\d" }, Xe = { arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881] }, tn = Ke.hanidec.replace(/[\[|\]]/g, "").split(""); function en({ numberingSystem: t }, e = "") { return new RegExp(`${Ke[t || "latn"]}${e}`) } function nn(t, e = (t => t)) { return { regex: t, deser: ([t]) => e(function (t) { let e = parseInt(t, 10); if (isNaN(e)) { e = ""; for (let n = 0; n < t.length; n++) { const s = t.charCodeAt(n); if (-1 !== t[n].search(Ke.hanidec)) e += tn.indexOf(t[n]); else for (const t in Xe) { const [n, r] = Xe[t]; s >= n && s <= r && (e += s - n) } } return parseInt(e, 10) } return e }(t)) } } function sn(t) { return t.replace(/\./, "\\.?") } function rn(t) { return t.replace(/\./, "").toLowerCase() } function an(t, e) { return null === t ? null : { regex: RegExp(t.map(sn).join("|")), deser: ([n]) => t.findIndex((t => rn(n) === rn(t))) + e } } function on(t, e) { return { regex: t, deser: ([, t, e]) => X(t, e), groups: e } } function un(t) { return { regex: t, deser: ([t]) => t } } const ln = { year: { "2-digit": "yy", numeric: "yyyyy" }, month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" }, day: { numeric: "d", "2-digit": "dd" }, weekday: { short: "EEE", long: "EEEE" }, dayperiod: "a", dayPeriod: "a", hour: { numeric: "h", "2-digit": "hh" }, minute: { numeric: "m", "2-digit": "mm" }, second: { numeric: "s", "2-digit": "ss" } }; let cn = null; function hn(t, e, n) { const s = function (t, e) { return Array.prototype.concat(...t.map((t => function (t, e) { if (t.literal) return t; const n = Ot.macroTokenToFormatOpts(t.val); if (!n) return t; const s = Ot.create(e, n).formatDateTimeParts((cn || (cn = Rn.fromMillis(1555555555555)), cn)).map((t => function (t, e, n) { const { type: s, value: r } = t; if ("literal" === s) return { literal: !0, val: r }; const i = n[s]; let a = ln[s]; return "object" == typeof a && (a = a[i]), a ? { literal: !1, val: a } : void 0 }(t, 0, n))); return s.includes(void 0) ? t : s }(t, e)))) }(Ot.parseFormat(n), t), i = s.map((e => function (t, e) { const n = en(e), s = en(e, "{2}"), r = en(e, "{3}"), i = en(e, "{4}"), a = en(e, "{6}"), o = en(e, "{1,2}"), u = en(e, "{1,3}"), l = en(e, "{1,6}"), c = en(e, "{1,9}"), h = en(e, "{2,4}"), d = en(e, "{4,6}"), m = t => { return { regex: RegExp((e = t.val, e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))), deser: ([t]) => t, literal: !0 }; var e }, f = (f => { if (t.literal) return m(f); switch (f.val) { case "G": return an(e.eras("short", !1), 0); case "GG": return an(e.eras("long", !1), 0); case "y": return nn(l); case "yy": case "kk": return nn(h, Q); case "yyyy": case "kkkk": return nn(i); case "yyyyy": return nn(d); case "yyyyyy": return nn(a); case "M": case "L": case "d": case "H": case "h": case "m": case "q": case "s": case "W": return nn(o); case "MM": case "LL": case "dd": case "HH": case "hh": case "mm": case "qq": case "ss": case "WW": return nn(s); case "MMM": return an(e.months("short", !0, !1), 1); case "MMMM": return an(e.months("long", !0, !1), 1); case "LLL": return an(e.months("short", !1, !1), 1); case "LLLL": return an(e.months("long", !1, !1), 1); case "o": case "S": return nn(u); case "ooo": case "SSS": return nn(r); case "u": return un(c); case "a": return an(e.meridiems(), 0); case "E": case "c": return nn(n); case "EEE": return an(e.weekdays("short", !1, !1), 1); case "EEEE": return an(e.weekdays("long", !1, !1), 1); case "ccc": return an(e.weekdays("short", !0, !1), 1); case "cccc": return an(e.weekdays("long", !0, !1), 1); case "Z": case "ZZ": return on(new RegExp(`([+-]${o.source})(?::(${s.source}))?`), 2); case "ZZZ": return on(new RegExp(`([+-]${o.source})(${s.source})?`), 2); case "z": return un(/[a-z_+-/]{1,256}?/i); default: return m(f) } })(t) || { invalidReason: "missing Intl.DateTimeFormat.formatToParts support" }; return f.token = t, f }(e, t))), a = i.find((t => t.invalidReason)); if (a) return { input: e, tokens: s, invalidReason: a.invalidReason }; { const [t, n] = function (t) { return [`^${t.map((t => t.regex)).reduce(((t, e) => `${t}(${e.source})`), "")}$`, t] }(i), a = RegExp(t, "i"), [o, u] = function (t, e, n) { const s = t.match(e); if (s) { const t = {}; let e = 1; for (const r in n) if (_(n, r)) { const i = n[r], a = i.groups ? i.groups + 1 : 1; !i.literal && i.token && (t[i.token.val[0]] = i.deser(s.slice(e, e + a))), e += a } return [s, t] } return [s, {}] }(e, a, n), [l, c] = u ? function (t) { let e; return e = x(t.Z) ? x(t.z) ? null : Vt.create(t.z) : new xt(t.Z), x(t.q) || (t.M = 3 * (t.q - 1) + 1), x(t.h) || (t.h < 12 && 1 === t.a ? t.h += 12 : 12 === t.h && 0 === t.a && (t.h = 0)), 0 === t.G && t.y && (t.y = -t.y), x(t.u) || (t.S = W(t.u)), [Object.keys(t).reduce(((e, n) => { const s = (t => { switch (t) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": case "H": return "hour"; case "d": return "day"; case "o": return "ordinal"; case "L": case "M": return "month"; case "y": return "year"; case "E": case "c": return "weekday"; case "W": return "weekNumber"; case "k": return "weekYear"; case "q": return "quarter"; default: return null } })(n); return s && (e[s] = t[n]), e }), {}), e] }(u) : [null, null]; if (_(u, "a") && _(u, "H")) throw new r("Can't include meridiem when specifying 24-hour format"); return { input: e, tokens: s, regex: a, rawMatches: o, matches: u, result: l, zone: c } } } const dn = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], mn = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]; function fn(t, e) { return new bt("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`) } function yn(t, e, n) { const s = new Date(Date.UTC(t, e - 1, n)).getUTCDay(); return 0 === s ? 7 : s } function gn(t, e, n) { return n + (J(t) ? mn : dn)[e - 1] } function wn(t, e) { const n = J(t) ? mn : dn, s = n.findIndex((t => t < e)); return { month: s + 1, day: e - n[s] } } function pn(t) { const { year: e, month: n, day: s } = t, r = gn(e, n, s), i = yn(e, n, s); let a, o = Math.floor((r - i + 10) / 7); return o < 1 ? (a = e - 1, o = B(a)) : o > B(e) ? (a = e + 1, o = 1) : a = e, Object.assign({ weekYear: a, weekNumber: o, weekday: i }, st(t)) } function vn(t) { const { weekYear: e, weekNumber: n, weekday: s } = t, r = yn(e, 1, 4), i = P(e); let a, o = 7 * n + s - r - 3; o < 1 ? (a = e - 1, o += P(a)) : o > i ? (a = e + 1, o -= P(e)) : a = e; const { month: u, day: l } = wn(a, o); return Object.assign({ year: a, month: u, day: l }, st(t)) } function Tn(t) { const { year: e, month: n, day: s } = t, r = gn(e, n, s); return Object.assign({ year: e, ordinal: r }, st(t)) } function On(t) { const { year: e, ordinal: n } = t, { month: s, day: r } = wn(e, n); return Object.assign({ year: e, month: s, day: r }, st(t)) } function bn(t) { const e = $(t.year), n = q(t.month, 1, 12), s = q(t.day, 1, Y(t.year, t.month)); return e ? n ? !s && fn("day", t.day) : fn("month", t.month) : fn("year", t.year) } function Sn(t) { const { hour: e, minute: n, second: s, millisecond: r } = t, i = q(e, 0, 23) || 24 === e && 0 === n && 0 === s && 0 === r, a = q(n, 0, 59), o = q(s, 0, 59), u = q(r, 0, 999); return i ? a ? o ? !u && fn("millisecond", r) : fn("second", s) : fn("minute", n) : fn("hour", e) } const Mn = "Invalid DateTime", kn = 864e13; function Nn(t) { return new bt("unsupported zone", `the zone "${t.name}" is not supported`) } function En(t) { return null === t.weekData && (t.weekData = pn(t.c)), t.weekData } function Dn(t, e) { const n = { ts: t.ts, zone: t.zone, c: t.c, o: t.o, loc: t.loc, invalid: t.invalid }; return new Rn(Object.assign({}, n, e, { old: n })) } function In(t, e, n) { let s = t - 60 * e * 1e3; const r = n.offset(s); if (e === r) return [s, e]; s -= 60 * (r - e) * 1e3; const i = n.offset(s); return r === i ? [s, r] : [t - 60 * Math.min(r, i) * 1e3, Math.max(r, i)] } function Vn(t, e) { const n = new Date(t += 60 * e * 1e3); return { year: n.getUTCFullYear(), month: n.getUTCMonth() + 1, day: n.getUTCDate(), hour: n.getUTCHours(), minute: n.getUTCMinutes(), second: n.getUTCSeconds(), millisecond: n.getUTCMilliseconds() } } function Ln(t, e, n) { return In(G(t), e, n) } function xn(t, e) { const n = Object.keys(e.values); -1 === n.indexOf("milliseconds") && n.push("milliseconds"), e = e.shiftTo(...n); const s = t.o, r = t.c.year + e.years, i = t.c.month + e.months + 3 * e.quarters, a = Object.assign({}, t.c, { year: r, month: i, day: Math.min(t.c.day, Y(r, i)) + e.days + 7 * e.weeks }), o = Je.fromObject({ hours: e.hours, minutes: e.minutes, seconds: e.seconds, milliseconds: e.milliseconds }).as("milliseconds"), u = G(a); let [l, c] = In(u, s, t.zone); return 0 !== o && (l += o, c = t.zone.offset(l)), { ts: l, o: c } } function Cn(t, e, n, s, r) { const { setZone: i, zone: a } = n; if (t && 0 !== Object.keys(t).length) { const s = e || a, r = Rn.fromObject(Object.assign(t, n, { zone: s, setZone: void 0 })); return i ? r : r.setZone(a) } return Rn.invalid(new bt("unparsable", `the input "${r}" can't be parsed as ${s}`)) } function $n(t, e, n = !0) { return t.isValid ? Ot.create(Qt.create("en-US"), { allowZ: n, forceSimple: !0 }).formatDateTimeFromString(t, e) : null } function Fn(t, { suppressSeconds: e = !1, suppressMilliseconds: n = !1, includeOffset: s, includeZone: r = !1, spaceZone: i = !1, format: a = "extended" }) { let o = "basic" === a ? "HHmm" : "HH:mm"; return e && 0 === t.second && 0 === t.millisecond || (o += "basic" === a ? "ss" : ":ss", n && 0 === t.millisecond || (o += ".SSS")), (r || s) && i && (o += " "), r ? o += "z" : s && (o += "basic" === a ? "ZZZ" : "ZZ"), $n(t, o) } const Zn = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, jn = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, zn = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, An = ["year", "month", "day", "hour", "minute", "second", "millisecond"], _n = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], qn = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; function Hn(t) { const e = { year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal" }[t.toLowerCase()]; if (!e) throw new i(t); return e } function Un(t, e) { for (const e of An) x(t[e]) && (t[e] = Zn[e]); const n = bn(t) || Sn(t); if (n) return Rn.invalid(n); const s = qt.now(), r = e.offset(s), [i, a] = Ln(t, r, e); return new Rn({ ts: i, zone: e, o: a }) } function Wn(t, e, n) { const s = !!x(n.round) || n.round, r = (t, r) => (t = R(t, s || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(t, r)), i = s => n.calendary ? e.hasSame(t, s) ? 0 : e.startOf(s).diff(t.startOf(s), s).get(s) : e.diff(t, s).get(s); if (n.unit) return r(i(n.unit), n.unit); for (const t of n.units) { const e = i(t); if (Math.abs(e) >= 1) return r(e, t) } return r(0, n.units[n.units.length - 1]) } class Rn { constructor(t) { const e = t.zone || qt.defaultZone; let n = t.invalid || (Number.isNaN(t.ts) ? new bt("invalid input") : null) || (e.isValid ? null : Nn(e)); this.ts = x(t.ts) ? qt.now() : t.ts; let s = null, r = null; if (!n) if (t.old && t.old.ts === this.ts && t.old.zone.equals(e)) [s, r] = [t.old.c, t.old.o]; else { const t = e.offset(this.ts); s = Vn(this.ts, t), n = Number.isNaN(s.year) ? new bt("invalid input") : null, s = n ? null : s, r = n ? null : t } this._zone = e, this.loc = t.loc || Qt.create(), this.invalid = n, this.weekData = null, this.c = s, this.o = r, this.isLuxonDateTime = !0 } static local(t, e, n, s, r, i, a) { return x(t) ? new Rn({ ts: qt.now() }) : Un({ year: t, month: e, day: n, hour: s, minute: r, second: i, millisecond: a }, qt.defaultZone) } static utc(t, e, n, s, r, i, a) { return x(t) ? new Rn({ ts: qt.now(), zone: xt.utcInstance }) : Un({ year: t, month: e, day: n, hour: s, minute: r, second: i, millisecond: a }, xt.utcInstance) } static fromJSDate(t, e = {}) { const n = (s = t, "[object Date]" === Object.prototype.toString.call(s) ? t.valueOf() : NaN); var s; if (Number.isNaN(n)) return Rn.invalid("invalid input"); const r = $t(e.zone, qt.defaultZone); return r.isValid ? new Rn({ ts: n, zone: r, loc: Qt.fromObject(e) }) : Rn.invalid(Nn(r)) } static fromMillis(t, e = {}) { if (C(t)) return t < -kn || t > kn ? Rn.invalid("Timestamp out of range") : new Rn({ ts: t, zone: $t(e.zone, qt.defaultZone), loc: Qt.fromObject(e) }); throw new a(`fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`) } static fromSeconds(t, e = {}) { if (C(t)) return new Rn({ ts: 1e3 * t, zone: $t(e.zone, qt.defaultZone), loc: Qt.fromObject(e) }); throw new a("fromSeconds requires a numerical input") } static fromObject(t) { const e = $t(t.zone, qt.defaultZone); if (!e.isValid) return Rn.invalid(Nn(e)); const n = qt.now(), s = e.offset(n), i = et(t, Hn, ["zone", "locale", "outputCalendar", "numberingSystem"]), a = !x(i.ordinal), o = !x(i.year), u = !x(i.month) || !x(i.day), l = o || u, c = i.weekYear || i.weekNumber, h = Qt.fromObject(t); if ((l || a) && c) throw new r("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (u && a) throw new r("Can't mix ordinal dates with month/day"); const d = c || i.weekday && !l; let m, f, y = Vn(n, s); d ? (m = _n, f = jn, y = pn(y)) : a ? (m = qn, f = zn, y = Tn(y)) : (m = An, f = Zn); let g = !1; for (const t of m) x(i[t]) ? i[t] = g ? f[t] : y[t] : g = !0; const w = d ? function (t) { const e = $(t.weekYear), n = q(t.weekNumber, 1, B(t.weekYear)), s = q(t.weekday, 1, 7); return e ? n ? !s && fn("weekday", t.weekday) : fn("week", t.week) : fn("weekYear", t.weekYear) }(i) : a ? function (t) { const e = $(t.year), n = q(t.ordinal, 1, P(t.year)); return e ? !n && fn("ordinal", t.ordinal) : fn("year", t.year) }(i) : bn(i), p = w || Sn(i); if (p) return Rn.invalid(p); const v = d ? vn(i) : a ? On(i) : i, [T, O] = Ln(v, s, e), b = new Rn({ ts: T, zone: e, o: O, loc: h }); return i.weekday && l && t.weekday !== b.weekday ? Rn.invalid("mismatched weekday", `you can't specify both a weekday of ${i.weekday} and a date of ${b.toISO()}`) : b } static fromISO(t, e = {}) { const [n, s] = function (t) { return te(t, [Ne, Ve], [Ee, Le], [De, xe], [Ie, Ce]) }(t); return Cn(n, s, e, "ISO 8601", t) } static fromRFC2822(t, e = {}) { const [n, s] = function (t) { return te(function (t) { return t.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim() }(t), [ve, Te]) }(t); return Cn(n, s, e, "RFC 2822", t) } static fromHTTP(t, e = {}) { const [n, s] = function (t) { return te(t, [Oe, Me], [be, Me], [Se, ke]) }(t); return Cn(n, s, e, "HTTP", e) } static fromFormat(t, e, n = {}) { if (x(t) || x(e)) throw new a("fromFormat requires an input string and a format"); const { locale: s = null, numberingSystem: r = null } = n, i = Qt.fromOpts({ locale: s, numberingSystem: r, defaultToEN: !0 }), [o, u, l] = function (t, e, n) { const { result: s, zone: r, invalidReason: i } = hn(t, e, n); return [s, r, i] }(i, t, e); return l ? Rn.invalid(l) : Cn(o, u, n, `format ${e}`, t) } static fromString(t, e, n = {}) { return Rn.fromFormat(t, e, n) } static fromSQL(t, e = {}) { const [n, s] = function (t) { return te(t, [$e, Ze], [Fe, je]) }(t); return Cn(n, s, e, "SQL", t) } static invalid(t, n = null) { if (!t) throw new a("need to specify a reason the DateTime is invalid"); const s = t instanceof bt ? t : new bt(t, n); if (qt.throwOnInvalid) throw new e(s); return new Rn({ invalid: s }) } static isDateTime(t) { return t && t.isLuxonDateTime || !1 } get(t) { return this[t] } get isValid() { return null === this.invalid } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } get outputCalendar() { return this.isValid ? this.loc.outputCalendar : null } get zone() { return this._zone } get zoneName() { return this.isValid ? this.zone.name : null } get year() { return this.isValid ? this.c.year : NaN } get quarter() { return this.isValid ? Math.ceil(this.c.month / 3) : NaN } get month() { return this.isValid ? this.c.month : NaN } get day() { return this.isValid ? this.c.day : NaN } get hour() { return this.isValid ? this.c.hour : NaN } get minute() { return this.isValid ? this.c.minute : NaN } get second() { return this.isValid ? this.c.second : NaN } get millisecond() { return this.isValid ? this.c.millisecond : NaN } get weekYear() { return this.isValid ? En(this).weekYear : NaN } get weekNumber() { return this.isValid ? En(this).weekNumber : NaN } get weekday() { return this.isValid ? En(this).weekday : NaN } get ordinal() { return this.isValid ? Tn(this.c).ordinal : NaN } get monthShort() { return this.isValid ? Be.months("short", { locale: this.locale })[this.month - 1] : null } get monthLong() { return this.isValid ? Be.months("long", { locale: this.locale })[this.month - 1] : null } get weekdayShort() { return this.isValid ? Be.weekdays("short", { locale: this.locale })[this.weekday - 1] : null } get weekdayLong() { return this.isValid ? Be.weekdays("long", { locale: this.locale })[this.weekday - 1] : null } get offset() { return this.isValid ? +this.o : NaN } get offsetNameShort() { return this.isValid ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale }) : null } get offsetNameLong() { return this.isValid ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale }) : null } get isOffsetFixed() { return this.isValid ? this.zone.universal : null } get isInDST() { return !this.isOffsetFixed && (this.offset > this.set({ month: 1 }).offset || this.offset > this.set({ month: 5 }).offset) } get isInLeapYear() { return J(this.year) } get daysInMonth() { return Y(this.year, this.month) } get daysInYear() { return this.isValid ? P(this.year) : NaN } get weeksInWeekYear() { return this.isValid ? B(this.weekYear) : NaN } resolvedLocaleOpts(t = {}) { const { locale: e, numberingSystem: n, calendar: s } = Ot.create(this.loc.clone(t), t).resolvedOptions(this); return { locale: e, numberingSystem: n, outputCalendar: s } } toUTC(t = 0, e = {}) { return this.setZone(xt.instance(t), e) } toLocal() { return this.setZone(qt.defaultZone) } setZone(t, { keepLocalTime: e = !1, keepCalendarTime: n = !1 } = {}) { if ((t = $t(t, qt.defaultZone)).equals(this.zone)) return this; if (t.isValid) { let s = this.ts; if (e || n) { const e = t.offset(this.ts), n = this.toObject();[s] = Ln(n, e, t) } return Dn(this, { ts: s, zone: t }) } return Rn.invalid(Nn(t)) } reconfigure({ locale: t, numberingSystem: e, outputCalendar: n } = {}) { return Dn(this, { loc: this.loc.clone({ locale: t, numberingSystem: e, outputCalendar: n }) }) } setLocale(t) { return this.reconfigure({ locale: t }) } set(t) { if (!this.isValid) return this; const e = et(t, Hn, []); let n; x(e.weekYear) && x(e.weekNumber) && x(e.weekday) ? x(e.ordinal) ? (n = Object.assign(this.toObject(), e), x(e.day) && (n.day = Math.min(Y(n.year, n.month), n.day))) : n = On(Object.assign(Tn(this.c), e)) : n = vn(Object.assign(pn(this.c), e)); const [s, r] = Ln(n, this.o, this.zone); return Dn(this, { ts: s, o: r }) } plus(t) { return this.isValid ? Dn(this, xn(this, Pe(t))) : this } minus(t) { return this.isValid ? Dn(this, xn(this, Pe(t).negate())) : this } startOf(t) { if (!this.isValid) return this; const e = {}, n = Je.normalizeUnit(t); switch (n) { case "years": e.month = 1; case "quarters": case "months": e.day = 1; case "weeks": case "days": e.hour = 0; case "hours": e.minute = 0; case "minutes": e.second = 0; case "seconds": e.millisecond = 0 }if ("weeks" === n && (e.weekday = 1), "quarters" === n) { const t = Math.ceil(this.month / 3); e.month = 3 * (t - 1) + 1 } return this.set(e) } endOf(t) { return this.isValid ? this.plus({ [t]: 1 }).startOf(t).minus(1) : this } toFormat(t, e = {}) { return this.isValid ? Ot.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this, t) : Mn } toLocaleString(t = h) { return this.isValid ? Ot.create(this.loc.clone(t), t).formatDateTime(this) : Mn } toLocaleParts(t = {}) { return this.isValid ? Ot.create(this.loc.clone(t), t).formatDateTimeParts(this) : [] } toISO(t = {}) { return this.isValid ? `${this.toISODate(t)}T${this.toISOTime(t)}` : null } toISODate({ format: t = "extended" } = {}) { let e = "basic" === t ? "yyyyMMdd" : "yyyy-MM-dd"; return this.year > 9999 && (e = "+" + e), $n(this, e) } toISOWeekDate() { return $n(this, "kkkk-'W'WW-c") } toISOTime({ suppressMilliseconds: t = !1, suppressSeconds: e = !1, includeOffset: n = !0, format: s = "extended" } = {}) { return Fn(this, { suppressSeconds: e, suppressMilliseconds: t, includeOffset: n, format: s }) } toRFC2822() { return $n(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1) } toHTTP() { return $n(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'") } toSQLDate() { return $n(this, "yyyy-MM-dd") } toSQLTime({ includeOffset: t = !0, includeZone: e = !1 } = {}) { return Fn(this, { includeOffset: t, includeZone: e, spaceZone: !0 }) } toSQL(t = {}) { return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null } toString() { return this.isValid ? this.toISO() : Mn } valueOf() { return this.toMillis() } toMillis() { return this.isValid ? this.ts : NaN } toSeconds() { return this.isValid ? this.ts / 1e3 : NaN } toJSON() { return this.toISO() } toBSON() { return this.toJSDate() } toObject(t = {}) { if (!this.isValid) return {}; const e = Object.assign({}, this.c); return t.includeConfig && (e.outputCalendar = this.outputCalendar, e.numberingSystem = this.loc.numberingSystem, e.locale = this.loc.locale), e } toJSDate() { return new Date(this.isValid ? this.ts : NaN) } diff(t, e = "milliseconds", n = {}) { if (!this.isValid || !t.isValid) return Je.invalid(this.invalid || t.invalid, "created by diffing an invalid DateTime"); const s = Object.assign({ locale: this.locale, numberingSystem: this.numberingSystem }, n), r = (o = e, Array.isArray(o) ? o : [o]).map(Je.normalizeUnit), i = t.valueOf() > this.valueOf(), a = function (t, e, n, s) { let [r, i, a, o] = function (t, e, n) { const s = [["years", (t, e) => e.year - t.year], ["months", (t, e) => e.month - t.month + 12 * (e.year - t.year)], ["weeks", (t, e) => { const n = Qe(t, e); return (n - n % 7) / 7 }], ["days", Qe]], r = {}; let i, a; for (const [o, u] of s) if (n.indexOf(o) >= 0) { i = o; let n = u(t, e); a = t.plus({ [o]: n }), a > e ? (t = t.plus({ [o]: n - 1 }), n -= 1) : t = a, r[o] = n } return [t, r, a, i] }(t, e, n); const u = e - r, l = n.filter((t => ["hours", "minutes", "seconds", "milliseconds"].indexOf(t) >= 0)); 0 === l.length && (a < e && (a = r.plus({ [o]: 1 })), a !== r && (i[o] = (i[o] || 0) + u / (a - r))); const c = Je.fromObject(Object.assign(i, s)); return l.length > 0 ? Je.fromMillis(u, s).shiftTo(...l).plus(c) : c }(i ? this : t, i ? t : this, r, s); var o; return i ? a.negate() : a } diffNow(t = "milliseconds", e = {}) { return this.diff(Rn.local(), t, e) } until(t) { return this.isValid ? Ge.fromDateTimes(this, t) : this } hasSame(t, e) { if (!this.isValid) return !1; if ("millisecond" === e) return this.valueOf() === t.valueOf(); { const n = t.valueOf(); return this.startOf(e) <= n && n <= this.endOf(e) } } equals(t) { return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc) } toRelative(t = {}) { if (!this.isValid) return null; const e = t.base || Rn.fromObject({ zone: this.zone }), n = t.padding ? this < e ? -t.padding : t.padding : 0; return Wn(e, this.plus(n), Object.assign(t, { numeric: "always", units: ["years", "months", "days", "hours", "minutes", "seconds"] })) } toRelativeCalendar(t = {}) { return this.isValid ? Wn(t.base || Rn.fromObject({ zone: this.zone }), this, Object.assign(t, { numeric: "auto", units: ["years", "months", "days"], calendary: !0 })) : null } static min(...t) { if (!t.every(Rn.isDateTime)) throw new a("min requires all arguments be DateTimes"); return z(t, (t => t.valueOf()), Math.min) } static max(...t) { if (!t.every(Rn.isDateTime)) throw new a("max requires all arguments be DateTimes"); return z(t, (t => t.valueOf()), Math.max) } static fromFormatExplain(t, e, n = {}) { const { locale: s = null, numberingSystem: r = null } = n; return hn(Qt.fromOpts({ locale: s, numberingSystem: r, defaultToEN: !0 }), t, e) } static fromStringExplain(t, e, n = {}) { return Rn.fromFormatExplain(t, e, n) } static get DATE_SHORT() { return h } static get DATE_MED() { return d } static get DATE_FULL() { return m } static get DATE_HUGE() { return f } static get TIME_SIMPLE() { return y } static get TIME_WITH_SECONDS() { return g } static get TIME_WITH_SHORT_OFFSET() { return w } static get TIME_WITH_LONG_OFFSET() { return p } static get TIME_24_SIMPLE() { return v } static get TIME_24_WITH_SECONDS() { return T } static get TIME_24_WITH_SHORT_OFFSET() { return O } static get TIME_24_WITH_LONG_OFFSET() { return b } static get DATETIME_SHORT() { return S } static get DATETIME_SHORT_WITH_SECONDS() { return M } static get DATETIME_MED() { return k } static get DATETIME_MED_WITH_SECONDS() { return N } static get DATETIME_MED_WITH_WEEKDAY() { return E } static get DATETIME_FULL() { return D } static get DATETIME_FULL_WITH_SECONDS() { return I } static get DATETIME_HUGE() { return V } static get DATETIME_HUGE_WITH_SECONDS() { return L } } function Jn(t) { if (Rn.isDateTime(t)) return t; if (t && t.valueOf && C(t.valueOf())) return Rn.fromJSDate(t); if (t && "object" == typeof t) return Rn.fromObject(t); throw new a(`Unknown datetime argument: ${t}, of type ${typeof t}`) } function Pn(t) { t.play() } const Yn = document.getElementById("datecalc"), Gn = document.getElementById("datecalc__result"); Yn.addEventListener("submit", (function (t) { Gn.innerHTML = "", t.preventDefault(); let { firstDate: e, secondDate: n } = t.target.elements; if (e = e.value, n = n.value, e && n) { const t = function (t, e) { return (t = Rn.fromISO(t)) > (e = Rn.fromISO(e)) && (e = [t, t = e][0]), e.diff(t, ["years", "months", "days"]).toObject() }(e, n); Gn.innerHTML = (t => ` \n    <span> \n        ${t.years ? "Лет: " + t.years : ""}\n        ${t.months ? "Месяцев: " + t.months : ""} \n        ${t.days ? "Дней: " + t.days : ""} \n    </span> \n`)(t) } else Gn.innerHTML = ("Для расчета промежутка необходимо заполнить оба поля", '\n<span style="color: red;">\n    Для расчета промежутка необходимо заполнить оба поля \n</span> \n') })); const Bn = document.getElementById("timer"); let Qn = document.getElementById("timer_remain"); document.getElementById("start"); const Kn = document.getElementById("stop"); let Xn, ts = new Audio("https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3"); Bn.addEventListener("submit", (function (t) { t.preventDefault(); let { time: e } = t.target.elements; e = e.value.split(":"), e = 1e3 * e[0] * 60 * 60 + 1e3 * e[1] * 60, setTimeout(Pn, e, ts), Xn = setInterval((() => { let t = Math.floor(e / 1e3 / 60 / 60), n = Math.floor((e - 1e3 * t * 60 * 60) / 1e3 / 60), s = Math.floor((e - 1e3 * t * 60 * 60 - 1e3 * n * 60) / 1e3); Qn.innerText = `${t} часов, ${n} минут, ${s} секунд`, e -= 1e3 }), 1e3) })), Kn.addEventListener("click", (function () { clearInterval(Xn), Qn.innerText = "", Bn.reset() })) })();